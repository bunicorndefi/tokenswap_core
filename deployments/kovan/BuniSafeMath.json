{
  "address": "0x940f9CC489A1A7dD47A135CdAcF9e8507A584c27",
  "abi": [],
  "transactionHash": "0x613c365958bfeb7c57db205bca90958bce55e884a2a6f542bb499334427d5064",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xba535ade958703Ffb99B9325ca8db04A00937029",
    "contractAddress": null,
    "transactionIndex": 4,
    "gasUsed": "72190",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2adcd19d933f00039fb5082811bdc37f069ec407e1fb3aa5774dc025dfe6c832",
    "transactionHash": "0x613c365958bfeb7c57db205bca90958bce55e884a2a6f542bb499334427d5064",
    "logs": [],
    "blockNumber": 24164618,
    "cumulativeGasUsed": "475034",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "44256da70cc812bee6154882727baa12",
  "metadata": "{\"compiler\":{\"version\":\"0.6.12+commit.27d51765\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"author\":\"Buni Labs\",\"details\":\"badd and bsub are basically identical to OpenZeppelin SafeMath; mul/div have extra checks\",\"kind\":\"dev\",\"methods\":{},\"title\":\"SafeMath - wrap Solidity operators to prevent underflow/overflow\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/utils/BuniSafeMath.sol\":\"BuniSafeMath\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000},\"remappings\":[]},\"sources\":{\"contracts/utils/BuniConstants.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n/**\\n * @author Buni Labs\\n * @title Put all the constants in one place\\n */\\n\\nlibrary BuniConstants {\\n    // State variables (must be constant in a library)\\n\\n    // B \\\"ONE\\\" - all math is in the \\\"realm\\\" of 10 ** 18;\\n    // where numeric 1 = 10 ** 18\\n    uint public constant BONE = 10**18;\\n    uint public constant MIN_WEIGHT = BONE;\\n    uint public constant MAX_WEIGHT = BONE * 50;\\n    uint public constant MAX_TOTAL_WEIGHT = BONE * 50;\\n    uint public constant MIN_BALANCE = BONE / 10**6;\\n    uint public constant MAX_BALANCE = BONE * 10**12;\\n    uint public constant MIN_POOL_SUPPLY = BONE * 100;\\n    uint public constant MAX_POOL_SUPPLY = BONE * 10**9;\\n    uint public constant MIN_FEE = BONE / 10**6;\\n    uint public constant MAX_FEE = BONE / 10;\\n    // EXIT_FEE must always be zero, or ConfigurableRightsPool._pushUnderlying will fail\\n    uint public constant EXIT_FEE = 0;\\n    uint public constant MAX_IN_RATIO = BONE / 2;\\n    uint public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\\n    // Must match BConst.MIN_BOUND_TOKENS and BConst.MAX_BOUND_TOKENS\\n    uint public constant MIN_ASSET_LIMIT = 2;\\n    uint public constant MAX_ASSET_LIMIT = 8;\\n    uint public constant MAX_UINT = uint(-1);\\n}\\n\",\"keccak256\":\"0x42607058118671667cb337e5381e06cae3d601c17b8b502d8a098bfc207c4529\",\"license\":\"GPL-3.0-or-later\"},\"contracts/utils/BuniSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.6.12;\\n\\n\\n// Imports\\n\\nimport \\\"./BuniConstants.sol\\\";\\n\\n/**\\n * @author Buni Labs\\n * @title SafeMath - wrap Solidity operators to prevent underflow/overflow\\n * @dev badd and bsub are basically identical to OpenZeppelin SafeMath; mul/div have extra checks\\n */\\nlibrary BuniSafeMath {\\n    /**\\n     * @notice Safe addition\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev if we are adding b to a, the resulting sum must be greater than a\\n     * @return - sum of operands; throws if overflow\\n     */\\n    function badd(uint a, uint b) internal pure returns (uint) {\\n        uint c = a + b;\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned subtraction\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev Do a signed subtraction, and check that it produces a positive value\\n     *      (i.e., a - b is valid if b <= a)\\n     * @return - a - b; throws if underflow\\n     */\\n    function bsub(uint a, uint b) internal pure returns (uint) {\\n        (uint c, bool negativeResult) = bsubSign(a, b);\\n        require(!negativeResult, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @notice Safe signed subtraction\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev Do a signed subtraction\\n     * @return - difference between a and b, and a flag indicating a negative result\\n     *           (i.e., a - b if a is greater than or equal to b; otherwise b - a)\\n     */\\n    function bsubSign(uint a, uint b) internal pure returns (uint, bool) {\\n        if (b <= a) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    /**\\n     * @notice Safe multiplication\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @dev Multiply safely (and efficiently), rounding down\\n     * @return - product of operands; throws if overflow or rounding error\\n     */\\n    function bmul(uint a, uint b) internal pure returns (uint) {\\n        // Gas optimization (see github.com/OpenZeppelin/openzeppelin-contracts/pull/522)\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // Standard overflow check: a/a*b=b\\n        uint c0 = a * b;\\n        require(c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n\\n        // Round to 0 if x*y < BONE/2?\\n        uint c1 = c0 + (BuniConstants.BONE / 2);\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c2 = c1 / BuniConstants.BONE;\\n        return c2;\\n    }\\n\\n    /**\\n     * @notice Safe division\\n     * @param dividend - first operand\\n     * @param divisor - second operand\\n     * @dev Divide safely (and efficiently), rounding down\\n     * @return - quotient; throws if overflow or rounding error\\n     */\\n    function bdiv(uint dividend, uint divisor) internal pure returns (uint) {\\n        require(divisor != 0, \\\"ERR_DIV_ZERO\\\");\\n\\n        // Gas optimization\\n        if (dividend == 0){\\n            return 0;\\n        }\\n\\n        uint c0 = dividend * BuniConstants.BONE;\\n        require(c0 / dividend == BuniConstants.BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n\\n        uint c1 = c0 + (divisor / 2);\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n\\n        uint c2 = c1 / divisor;\\n        return c2;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer modulo\\n     * @dev Returns the remainder of dividing two unsigned integers.\\n     *      Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * @param dividend - first operand\\n     * @param divisor - second operand -- cannot be zero\\n     * @return - quotient; throws if overflow or rounding error\\n     */\\n    function bmod(uint dividend, uint divisor) internal pure returns (uint) {\\n        require(divisor != 0, \\\"ERR_MODULO_BY_ZERO\\\");\\n\\n        return dividend % divisor;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer max\\n     * @dev Returns the greater of the two input values\\n     *\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @return - the maximum of a and b\\n     */\\n    function bmax(uint a, uint b) internal pure returns (uint) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer min\\n     * @dev returns b, if b < a; otherwise returns a\\n     *\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @return - the lesser of the two input values\\n     */\\n    function bmin(uint a, uint b) internal pure returns (uint) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @notice Safe unsigned integer average\\n     * @dev Guard against (a+b) overflow by dividing each operand separately\\n     *\\n     * @param a - first operand\\n     * @param b - second operand\\n     * @return - the average of the two values\\n     */\\n    function baverage(uint a, uint b) internal pure returns (uint) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n\\n    /**\\n     * @notice Babylonian square root implementation\\n     * @dev (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n     * @param y - operand\\n     * @return z - the square root result\\n     */\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        }\\n        else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x28c34942509b641885d066ec59037b9d641465f1b6a11e21035c5e2c2406702f\",\"license\":\"GPL-3.0-or-later\"}},\"version\":1}",
  "bytecode": "0x60566023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220340710d7444e8006e0a1039ff90db56341b87d0901012bc73634eeae25c2526064736f6c634300060c0033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220340710d7444e8006e0a1039ff90db56341b87d0901012bc73634eeae25c2526064736f6c634300060c0033",
  "devdoc": {
    "author": "Buni Labs",
    "details": "badd and bsub are basically identical to OpenZeppelin SafeMath; mul/div have extra checks",
    "kind": "dev",
    "methods": {},
    "title": "SafeMath - wrap Solidity operators to prevent underflow/overflow",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}